{"version":3,"sources":["taoensso/tufte/impl.cljc"],"mappings":";;;;;AAiCA,AAAA;;;;;;;;AAAA;AAAA,AAAA,AAAA,AAASI;AAAT,AAAA,AAAA;;;AAAA,AAAA,AAAA,AAASA;;AAAT,AAAA,AAAA,AAASA;;AAAT,AAAA,AAAA,AAAAJ,AAAAC,AAAAC,AAASE;AAAT,AAAA,AAAAD,AAAAF,AAAA;;;AAAA;;;AAAA,AAASI,AAAUC,AAASC;AAA5B,AAAA,AAAAH,AAAmBE,AAASC;;;AAAnBH,AACT,AAAA;;;;;;;;AAAA;AAAA,AAAA,AAAA,AAASI;AAAT,AAAA,AAAA;;;AAAA,AAAA,AAAA,AAASA;;AAAT,AAAA,AAAA,AAASA;;AAAT,AAAA,AAAA,AAAAR,AAAAC,AAAAC,AAASM;AAAT,AAAA,AAAAL,AAAAF,AAAA;;;AAAA;;;AAAA,AAASQ,AAAgBC,AAASC;AAAlC,AAAA,AAAAH,AAAyBE,AAASC;;;AAAzBH,AACT,AAMA,AAKA,AAAA;;;;;;;;;;;;;;AAAA,AAAA,AAAA,AAAA,AAAA,AAASK,AAEuCK;;AAFhD,AAAA,AAAA,AAEgDA;AAFhD,AAAA,AAAAN,AAE8DK;;;AAF9D,AAAA,AAAA,AAAA,AAASJ,AAIuCK;;AAJhD,AAAA,AAAA,AAIgDA;AAJhD,AAImD,AAACC,AAAUF;;;AAJ9D,AAAA,AAAA,AAASJ;AAAT,AAAA,AAAA;;;AAAA,AAAA,AAAA,AAASA;;AAAT,AAAA,AAAA,AAASA;;AAAT,AAAA,AAAA,AAAAb,AAAAC,AAAAC,AAASW;AAAT,AAAA,AAAAV,AAAAF,AAAA;;;AAAA;;;AAAA,AAASa,AAAQC,AAASJ,AAAGK,AAAOC;AAApC,AAAA,AAAAJ,AAAiBE,AAASJ,AAAGK,AAAOC;;;AAA3BJ,AAWT,AAAA,AACA,AAAA;;;;;;;;;AAAA;AAAA,AAAA,AAAA,AAASO;AAAT,AAAA,AAAA;;;AAAA,AAAA,AAAA,AAASA;;AAAT,AAAA,AAAA,AAASA;;AAAT,AAAA,AAAA,AAAApB,AAAAC,AAAAC,AAASkB;AAAT,AAAA,AAAAjB,AAAAF,AAAA;;;AAAA;;;AAAA,AAASoB,AAAQC,AAAIC,AAASC;AAA9B,AAAA,AAAAJ,AAAiBE,AAAIC,AAASC;;;AAArBJ,AACT,AAAA;;;;;;;;;;;;AAAA,AAAA,AAAA,AAAA,AAAA,AAAUK,AAEgCI;;AAF1C,AAAA,AAAA,AAE0CA;AAF1C,AAEgD,AAACC,AAAAA,AAAAA,AAAYD,AAAAA;;;AAF7D,AAAA,AAAA,AAAUJ;AAAV,AAAA,AAAA;;;AAAA,AAAA,AAAA,AAAUA;;AAAV,AAAA,AAAA,AAAUA;;AAAV,AAAA,AAAA,AAAAzB,AAAAC,AAAAC,AAAUuB;AAAV,AAAA,AAAAtB,AAAAF,AAAA;;;AAAA;;;AAAA,AAAUyB,AAAaC,AAAWjB,AAAGkB;AAArC,AAAA,AAAAH,AAAuBE,AAAWjB,AAAGkB;;;AAA3BH,AAIV,AAAA,AAAMM,AAAyBJ;AAA/B,AAAqC,AAAMjB,AAAG,AAAAsB,AAAAA,AAAAA;AAAT,AAA0B,AAAAP,AAAQE,AAAKjB,AAAG,AAACuB,AAAU,AAAAb,AAAA,AAAA,AAAS;;AACnG,AAAA,AAAMc,AAAyBP;AAA/B,AAAqC,AAAMjB,AAAG,AAAAsB,AAAAA,AAAAA;AAAT,AAA0B,AAAAP,AAAQE,AAAKjB,AAAG,AAACyB,AAAU,AAAAf,AAAA,AAAA,AAAS,AAAA,AAACe;;AAEpG,AAEA,AAAA,AACA;;;AAAA,AAAOL,AAAoCf;AAA3C,AAEE,AAAMJ,AAAO,AAAAqB,AAAAA,AAAAA;AACPtB,AAAO,AAAMK;AACbC,AAAO,AAAAoB,AAAA,AAAA,AAAA,AAAA,AAAM,AAAA5B,AAAWE,AAAGC;AAFjC,AAIE,AAAAE,AAASE,AAAGJ,AAAGK,AAAO,AAAAqB,AAAA;AAAA,AAAO,AAACC,AAAAA,AAAAA,AAAavB,AAAAA,AAAGJ,AAAAA,AAAGK,AAAAA;AAA3B;;AAE1B,AAEA;;;AAAA,AAAeuB;AAkBZ,AAAA,AAAMC;AACAC,AAAO,AAAA,AAACR;AADd,AAGE,AAAA,AAAMS;AAAN,AAAA,AAAA9B,AAA0B6B;;;AAC1B,AAAA,AAAME;AAAN,AACE,AAAAC,AAAiB,AAAMJ;AAAvB,AAAA,AAAAI;AAAA,AAAAA,AAASC;AAAT,AACE,AAACC,AAAQL,AAAOI;;AAChB,AAAA,AAACC,AAAQL;;;;AAEb,AAAA,AAAMM,AAAkBC;AAAxB,AACE,AAAAJ,AAAA,AAAAhC,AAAmB6B;AAAnB,AAAA,AAAAG;AAAA,AAAAA,AAASK;AAAT,AACE,AAAI,AAAOT,AAAMS;;AAAU,AAACH,AAAQL,AAAOO;;AAC3C,AAA2B,AAACF,AAAQL,AAAOO;;;AAEpD,AAUA,AAAA;;;;;;;;AAAA;AAAA,AAAA,AAAA,AAASE;AAAT,AAAA,AAAA;;;AAAA,AAAA,AAAA,AAASA;;AAAT,AAAA,AAAA,AAASA;;AAAT,AAAA,AAAA,AAAAlD,AAAAC,AAAAC,AAASgD;AAAT,AAAA,AAAA/C,AAAAF,AAAA;;;AAAA;;;AAAA,AAASkD,AAAsBC,AAAWC;AAA1C,AAAA,AAAAH,AAA+BE,AAAWC;;;AAAjCH,AACT,AAAMI,AAAY,AAAKtC;AAAL,AAAa,AAACuC,AAAQ,AAAeC;AAAf,AAAsB,AAAMA;AAAQxC;;AAA5E,AACE;;;;AAAA,AAAOyC,AAGEzC;AAHT,AAIE,AAAI,AAAC0C,AAAO1C;AAAZ;;AAEE,AAAM2C,AAAc,AAACL,AAAYtC;AAAjC,AACE,AAAQ,AACL4C,AACC,AAAqBtC,AAAckC;AAAnC,AACE,AAAM7C,AAAO,AAAU6C;AACjBH,AAAO,AAAU/B;AADvB,AAEE,AAAI,AAAGX,AAAG0C;AACR,AAAM3C,AAAK,AAAQ8C;AACbJ,AAAK,AAAQ9B;AADnB,AAEE,AAAA4B,AAAiB,AAAGE,AAAK,AAAGzC,AAAG,AAACkD,AAASnD,AAAG2C,AAAU1C;;AACxDW;;AACN,AAAA4B,AAAA,AAAA,AACAS;;;AAEZ,AAcA,AAAA,AAAOG,AAAoBnC,AAAWhB,AAAGoD,AAAQC;AAAjD,AACE,AAAMC,AAAQ,AAACC,AAAMH;AACfI,AAAQ,AAACD,AAAMF;AACfI,AAAQ,AAAI,AAAGD,AAAGF,AAAI,AAACI,AAAKL,AAAQD,AAAS,AAACM,AAAKN,AAAQC;AAFjE,AAIE,AAAI,AAAG,AAAGC,AAAGE,AAAIxC;AACf,AAAMyB,AAAK,AAACK,AAAaW;AAAzB,AACE,AAAAhC,AAAA,AAAA,AAAA,AAAA,AAAM,AAAA5B,AAAW,AAAGG,AAAGyC,AAAMzC;;AAC/ByD;;;AAEN,AAOA;;;AAAA,AAAOE,AAEJC,AAAYC;AAFf,AAGE,AAACC,AACC,AAAA7B,AAAoB,AAAC8B,AAAcF;AAAnC,AAAA,AAAA5B;AAAA,AAAAA,AAAS4B;AAAT,AACE,AAACG,AACC,AAACf,AACC,AAAKgB,AAAQC;AAAb,AACE,AAAMvE,AAAG,AAAMuE;AACTtE,AAAG,AAAMsE;AADf,AAEE,AAACC,AAAOF,AAAEtE,AAAG,AAACyE,AAAK,AAACC,AAAIJ,AAAEtE,AAAIC;AAClC,AAAC0E,AAAU,AAAAC,AAAIX;AAAJ,AAAA,AAAAW;AAAAA;;AAAA;;AACXV;;AACJD;;;;AAEN,AAOA;;;AAAA,AAAOjC,AAEGvB,AAASJ,AAAGK;AAFtB,AAGE,AAAMN,AAAQ,AAAWK;AACnBa,AAAQ,AAAWb;AACXoE,AAAO,AAACT,AAAc9C;AAC9BL,AAAS,AAAY4D;AACrB3D,AAAS,AAAY2D;AACrB5D,AAAS,AAAC+C,AAAoB/C,AAAS,AAAO4D;AAC9C3D,AACA,AAAC4D,AACC,AAAKR,AAAEtE,AAAG+E;AAAV,AACE,AAAMC,AAAY,AAACC,AAAYF;AACzBG,AAAO,AAAC5B,AAAO6B,AAAkBH,AAAY,AAACN,AAAIxD,AAASlB;AADjE,AAEE,AAACoF,AAAMd,AAAEtE,AAAGkF;AAChBjE,AACAA;AAbR,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAeUC,AACKd,AAAOC,AAAU,AAAC8C,AAAazC;;AAEhD,AAEA,AAAA,AAAO2E,AAAWC,AAAGC;AAArB,AAAyB,AAAI,AAAG,AAAC3B,AAAM0B,AAAI,AAAC1B,AAAM2B;AAAK,AAACxB,AAAKuB,AAAGC;;AAAI,AAACxB,AAAKwB,AAAGD;;;AAC7E,AAEA,AAAA,AAAOE,AAA+BnE,AAAKoE;AAA3C,AACE,AAAI,AAAI,AAAC7B,AAAM6B,AAAOpE;AACpBoE;;AACA,AAAA3D,AAAA,AAAA,AAAA,AAAA,AAAM,AAAC4D,AAAOP,AAAkBM;;;AAEpC,AAAA;;;AAAA,AAAAE,AAAME;AAAN,AAAA,AAAAD,AAAA,AAAA;AAAA,AAAA,AAAAA;AAAA;AAAA,AAAAC,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA;;;AAAA;AAAA,AAAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA;;;;AAAA,AAAA,AAAAC,AAAA,AAAA,AAAA,AAAA;;;;;AAAA,AAAA,AAAA,AAAMD,AACGE,AAAIC;AADb,AACkB,AAAA,AAACC,AAAiBF,AAAIC;;;AADxC,AAAA,AAAA,AAAMH,AAEFxE,AAAK0E,AAAIC;AAFb,AAGG,AAAID;AACF,AAAIC;AACF,AAAcD,AAAUA;AACVC,AAAUA;AACVI,AAAI,AAAML;AACVM,AAAI,AAAML;AAElB3E,AAAK,AAACiF,AAAK,AAAA1B,AAAIvD;AAAJ,AAAA,AAAAuD;AAAAA;;AAAS,AAAQwB;;;AAC5BG,AAAO,AAAMH;AACbI,AAAO,AAAMT;AACbU,AAAO,AAAMJ;AACbK,AAAO,AAAMV;AAEbW,AAAQ,AAAI,AAAGJ,AAAOE,AAAQF,AAAOE;AACrCG,AAAQ,AAAI,AAAGJ,AAAOE,AAAQF,AAAOE;AACrC5C,AAAQ,AAACN,AAAanC,AAAKuF,AAAO,AAAUb,AAAK,AAAUC;AAEnDa,AAAW,AAACzC,AAAc,AAAWgC;AACrCU,AAAW,AAAC1C,AAAc,AAAWiC;AAE7CU,AAAa,AAAC/C,AAAoB,AAAY6C,AAAY,AAAOA;AACjEG,AAAa,AAAChD,AAAoB,AAAY8C,AAAY,AAAOA;AACjEG,AAAa,AAAYJ;AACzBK,AAAa,AAAYJ;AAGzBK,AAAQ,AAACC,AAAK,AAAC3C,AAAK,AAAAG,AAAImC;AAAJ,AAAA,AAAAnC;AAAAA;;AAAA;;AAAqBoC;AAxB/Cd,AA4BM,AAAC5C,AACC,AAAAiE,AAAiCvH;AAAjC,AAAA,AAAAwH,AAAAD;AAAA,AAAApB,AAAAqB,AAAA,AAAA,AAAMH;AAAN,AAAAlB,AAAAqB,AAAA,AAAA,AAAmBF;AAAnB,AACE,AAAMG,AAAU,AAAC/C,AAAIqC,AAAa/G;AAC5B0H,AAAU,AAAChD,AAAIuC,AAAajH;AAC5B2H,AAAU,AAACjD,AAAIsC,AAAahH;AAC5B4H,AAAU,AAAClD,AAAIwC,AAAalH;AAE5B6H,AAAU,AAACxC,AAAUoC,AAAUE;AAC/BG,AAAU,AAACzC,AAAUqC,AAAUE;AANrC,AAQE,AAAI,AAAI,AAAChE,AAAMiE,AAAWxG;AAA1B,AACG,AAAC+D,AAAMiC,AAAarH,AAAG6H,AACvB,AAACzC,AAAMkC,AAAatH,AAAG8H;;AAGxB,AAAM9C,AAAY,AAACC,AAAY4C;AAA/B,AAAA,AACG,AAAA,AAACzC,AAAMiC,AAAarH,AACpB,AAACoF,AAAMkC,AAAatH,AAClB,AAACwF,AAAwBnE,AACvB,AAACoD,AAAKqD,AAAU9C;;AAnB/B,AAqBG+B,AAAaE,AACdE;AAlDR,AAAAhB,AAAAD,AAAA,AAAA,AA2BOmB;AA3BP,AAAAlB,AAAAD,AAAA,AAAA,AA2BoBoB;AAyBdS,AAAI,AAAA5G,AAAQE,AAAKsF,AAAO,AAAA7F,AAAA,AAAauG,AAAaC;AApDxD,AAqDE,AAAA/G,AAASwH,AAAInB,AAAO9C,AAAQ,AAAA/B,AAAA;AAAA,AAAO,AAACC,AAAa+F,AAAInB,AAAO9C;AAAhC;;AAE9BiC;;;AACFC;;;;AA7DL,AAAA,AAAA,AAAMH;;AAAN,AAsEA,AAAA,AACA,AAAA,AAAMmC,AAAsBvH,AAAGT,AAAGiI;;AAAlC,AACE,AAAM5G,AAAQ,AAAWZ;AACnBa,AAAQ,AAAWb;AADzB,AAAAH,AAEcuE,AAAQvD;AAChBN,AAAI,AAAO6D;AAHjB,AAKE,AAAI,AAAAqD,AAAOlH;AAGT,AAAMmH,AACA;AAAA,AACE,AAAA,AAAA7H,AAAM8H,AAAWpH;AACXqH,AAAU,AAAC5D,AAAK2D,AAAU,AAAAtI,AAAOE,AAAGiI;AAD1C,AAEE,AAAI,AAAI,AAACrE,AAAMyE,AAAWhH;AACxB,AAAI,AAACiH,AAAiBtH,AAAIoH,AAAUC;AAApC;;AAAmD;;;AACnD,AAAI,AAAA,AAACC,AAAiBtH,AAAIoH;AAAeC;;AAAU;;;;;;AAN/D,AAQE,AAAAE,AAAiBJ;AAAjB,AAAA,AAAAI;AAAA,AAAA,AAAAA,AAAWxD;AAAX,AACE,AAAM3E,AAAG,AAAAsB,AAAAA,AAAAA;AAAT,AAEE,AAAC8G,AAAMlH,AAAQ;AAAKuD;AAAL,AAAa,AAAA,AAAA,AAAC4D,AAAAA,AAAAA,AAAe5D,AAAAA,AAAOE,AAAAA,AAAM1D,AAAAA;;;;AACzD,AAAOZ;AAAP;AAA4B,AAAG,AAAAiB,AAAAA,AAAAA,AAAgBtB;;;;;;AAJnD;;;AAMF,AACE,AAAQY,AAAI,AAAAlB,AAAOE,AAAGiI;;AAEtB,AAAM,AAAG,AAAUjH,AAAKK;AAAxB,AACE,AAAMjB,AAAG,AAAAsB,AAAAA,AAAAA;AAAT,AACE,AAACc,AAAQlB,AAAQ,AAAA,AAAA,AAACmH,AAAAA,AAAAA,AAAe5D,AAAAA,AAAO7D,AAAAA,AAAIK,AAAAA;;AAC5C,AAAOZ;AAAP;AAA4B,AAAG,AAAAiB,AAAAA,AAAAA,AAAgBtB;;;;;;AAHnD;;;;;;AAKR,AAAA,AAAOqI,AAAwB5D,AAAO6D,AAAmBrH,AAAKsH;AAA9D,AAGE,AAAM1H,AAAS,AAAY4D;AACrB3D,AAAS,AAAY2D;AACrB5D,AAAS,AAAC+C,AAAoB/C,AAASyH;AAF7CE,AAKM,AAAC9D,AACC,AAAK9D,AAAIhB,AAAG+E;AAAZ,AACE,AAAI,AAAI,AAACnB,AAAMmB,AAAO1D;AACpBL;;AACA,AAAA6H,AAA0B7H;AAA1B,AAAAmF,AAAA0C,AAAA,AAAA,AAAO5H;AAAP,AAAAkF,AAAA0C,AAAA,AAAA,AAAgB3H;AACV8D,AAAY,AAACC,AAAYF;AAD/B,AAAA,AAEG,AAAA,AAACK,AAAMnE,AAASjB,AAChB,AAACoF,AAAMlE,AAASlB,AACd,AAACwF,AAAwBnE,AACvB,AAACoD,AAAK,AAACC,AAAIxD,AAASlB,AAAIgF;;AATrC,AAWG/D,AAASC,AACVD;AAjBR,AAAAkF,AAAAyC,AAAA,AAAA,AAIO3H;AAJP,AAAAkF,AAAAyC,AAAA,AAAA,AAIgB1H;AAeV4H,AAAQ,AAAIH,AAAS,AAAO9D,AAAQ;AAnB1C,AAqBE,AAAA/D,AAASgI,AAAQ7H,AAASC;;AAE9B,AAQA,AAAA,AAAA6H,AAAAC,AAAAC,AAAAC;AAAA;AAAA,AAAA;;;AAAaC,AAAiC,AAAA,AAACtH;;AAQ/C,AAAA,AAAOuH,AAAkB9E;AAAzB,AACE,AAAC+E,AACC,AAAKrJ,AAAGsJ;AAAR,AACE,AAAA,AAAc,AAACA,AAAAA,AAAAA,AAAEhF,AAAAA;AAAjB,AAAAiF,AAAoBC;AAApB,AACE,AAAA,AACE,AAACE,AAAQ,AAAA,AAAA,AAAiC1J,AAAuBwJ;AADnE,AAAA5I,AAAA6I;AAAA,AAAA;AAHN,AAAAnJ,AAKG6I;;AAGI,AAAA,AAAMQ,AAASrF;AAAf,AAAkB,AAAC8E,AAAiB9E;;AAApC","names":["this__4428__auto__","writer__4429__auto__","opt__4430__auto__","cljs.core/-write","taoensso.tufte.impl/Time","taoensso.tufte.impl/->Time","id","t","taoensso.tufte.impl/TimeSpan","taoensso.tufte.impl/->TimeSpan","t0","t1","cljs.core/deref","taoensso.tufte.impl/PStats","taoensso.tufte.impl/->PStats","pd","tspans","realized_","_","cljs.core/realized?","taoensso.tufte.impl/PState","taoensso.tufte.impl/->PState","acc","id-times","id-stats","taoensso.tufte.impl/PData","taoensso.tufte.impl/->PData","nmax","pstate_","this","taoensso.tufte.impl/deref-pdata","taoensso.tufte.impl/new-pdata-local","taoensso.encore/now-nano","cljs.core/volatile!","taoensso.tufte.impl/new-pdata-dynamic","cljs.core.atom.cljs$core$IFn$_invoke$arity$1","cljs.core/List","cljs.core/Delay","taoensso.tufte.impl/deref-pstats","taoensso.tufte.impl/*pdata*","stack","state_","taoensso.tufte.impl/pdata-proxy-get","taoensso.tufte.impl/pdata-proxy-pop","temp__5733__auto__","stashed","cljs.core/vreset!","taoensso.tufte.impl/pdata-proxy-push","v","to-stash","taoensso.tufte.impl/ElapsedTimeAcc","taoensso.tufte.impl/->ElapsedTimeAcc","tsum","max-t1","sort-tspans","cljs.core.sort_by.cljs$core$IFn$_invoke$arity$2","tspan","taoensso.tufte.impl/tspans->tsum","cljs.core/empty?","sorted-tspans","cljs.core.reduce.cljs$core$IFn$_invoke$arity$3","Math/max","taoensso.tufte.impl/merge-tspans","tspans0","tspans1","n0","cljs.core/count","n1","tspans2","cljs.core.into.cljs$core$IFn$_invoke$arity$2","taoensso.tufte.impl/times-into-id-times","to-id-times","from-times","cljs.core/not-empty","taoensso.encore/force-ref","cljs.core/persistent!","m","in","cljs.core.assoc_BANG_.cljs$core$IFn$_invoke$arity$3","cljs.core.conj.cljs$core$IFn$_invoke$arity$2","cljs.core.get.cljs$core$IFn$_invoke$arity$2","cljs.core/transient","or__4185__auto__","pstate","cljs.core/reduce-kv","times","stats<times","taoensso.tufte.stats/stats","merged","taoensso.tufte.stats/merge-stats","cljs.core.assoc.cljs$core$IFn$_invoke$arity$3","taoensso.tufte.impl/fast-into","c0","c1","taoensso.tufte.impl/merge-stats-when-needed","stats","cljs.core.reduce.cljs$core$IFn$_invoke$arity$2","var_args","G__29486","taoensso.tufte.impl/merge-pstats","js/Error","ps0","ps1","taoensso.tufte.impl.merge_pstats.cljs$core$IFn$_invoke$arity$3","vec__29488","cljs.core.nth.cljs$core$IFn$_invoke$arity$3","pd0","pd1","cljs.core/long","pd0-t0","ps0-t1","pd1-t0","ps1-t1","pd2-t0","ps2-t1","pd0-pstate","pd1-pstate","pd0-id-times","pd1-id-times","pd0-id-stats","pd1-id-stats","pd2-ids","cljs.core/keys","pd2-id-times","pd2-id-stats","p__29491","vec__29492","pd0-times","pd0-stats","pd1-times","pd1-stats","pd2-times","pd2-stats","pd2","taoensso.tufte.impl/capture-time!","ns-elapsed","cljs.core/Atom","?pulled-times","old-times","new-times","cljs.core/compare-and-set!","temp__5735__auto__","cljs.core.swap_BANG_.cljs$core$IFn$_invoke$arity$2","taoensso.tufte.impl/compact-pstate","pulled-times","dynamic?","vec__29500","vec__29503","new-acc","js/taoensso","js/taoensso.tufte","js/taoensso.tufte.impl","js/taoensso.tufte.impl.handlers_","taoensso.tufte.impl/handlers_","taoensso.tufte.impl/handle-blocking!","taoensso.encore/run-kv!","f","e29508","e","e29509","cljs.core.println.cljs$core$IFn$_invoke$arity$variadic","taoensso.tufte.impl/handle!"],"sourcesContent":["(ns taoensso.tufte.impl\n  \"Private implementation details.\n  `profiled` -> [<result> <derefable-and-mergeable-pstats>].\n\n  Profiling consists of:\n    1. State init   ; On  thread\n    2. Capture      ; On  thread\n    3. State deref  ; On  thread\n    4. ?Merging     ; Off thread, on demand (deferred cost)\n    5. ?Realization ; Off thread, on demand (deferred cost)\n\n  Basic implementation:\n    - Capture [<id> <elapsed>]s into single mutable acc\n      - May compact acc      to id-times, {<id> (<time>        ...)}\n      - May compact id-times to id-stats, {<id> (<stats/stats> ...)}\n    - Merge pours (read-only) acc0 + acc1 into id-times\n      - May compact id-times to id-stats, {<id> (<stats/stats> ...)}\n    - Realization:\n        - Generates {<id> <stats/stats>} from id-times.\n        - Merges with id-stats.\"\n\n  (:require [clojure.string  :as str]\n            [taoensso.encore :as enc :refer-macros []]\n            [taoensso.tufte.stats :as stats])\n  #?(:clj\n     (:import [java.util LinkedList]\n              [java.util.concurrent ArrayBlockingQueue]))\n  #?(:cljs\n     (:require-macros\n      [taoensso.tufte.impl :refer [mt-acc mt-add mt-count atom?]])))\n\n;;;; Mutable accumulators\n\n(deftype Time     [id ^long t])\n(deftype TimeSpan [^long t0 ^long t1])\n(comment (enc/qb 1e6 (Time. :foo 1000))) ; 33.59\n\n(defmacro ^:private mt-acc     [] `(enc/if-cljs (cljs.core/array) (LinkedList.)))\n(defmacro ^:private mt-add [mt x] `(enc/if-cljs (.push   ~mt ~x) (.add  ~(with-meta mt {:tag 'LinkedList}) ~x)))\n(defmacro ^:private mt-count [mt] `(enc/if-cljs (alength ~mt)    (.size ~(with-meta mt {:tag 'LinkedList}))))\n\n(comment (enc/qb 1e6 (mt-acc) (atom nil))) ; [29.14 57.76]\n\n;;;; PStats (Profiling Stats)\n;; API-level state we'll return from `profiled`: derefable, mergeable\n\n(deftype PStats [pd ^long t1 tspans realized_]\n  #?@(:clj  [clojure.lang.IDeref    (deref     [_]           @realized_)]\n      :cljs [             IDeref   (-deref     [_]           @realized_)])\n  #?@(:clj  [clojure.lang.IPending (isRealized [_] (realized? realized_))]\n      :cljs [             IPending (-realized? [_] (realized? realized_))]))\n\n;;;; PData (Profiling Data)\n;; Implementation-level state while profiling,\n;;   - id-times: ?{<id> (<time>        ...)}\n;;   - id-stats: ?{<id> (<stats/stats> ...)}\n\n(declare ^:private deref-pdata)\n(deftype PState [acc id-times id-stats])\n(deftype  PData [^long nmax ^long t0 pstate_]\n  #?@(:clj  [clojure.lang.IDeref  (deref [this] (deref-pdata this))]\n      :cljs [             IDeref (-deref [this] (deref-pdata this))]))\n\n(defn new-pdata-local   [^long nmax] (let [t0 (enc/now-nano*)] (PData. nmax t0 (volatile! (PState. (mt-acc)   nil nil)))))\n(defn new-pdata-dynamic [^long nmax] (let [t0 (enc/now-nano*)] (PData. nmax t0 (atom      (PState. (atom nil) nil nil)))))\n\n(comment (enc/qb 1e6 (new-pdata-local 10) (new-pdata-dynamic 10))) ; [98.18 138.28]\n\n(declare ^:private deref-pstats)\n(defn- deref-pdata \"PData->PStats\" [^PData pd]\n  ;; NB (.-acc pd) should never be mutated from this point!\n  (let [t1     (enc/now-nano*)\n        t0     (.-t0 pd)\n        tspans (list (TimeSpan. t0 t1))]\n\n    (PStats. pd t1 tspans (delay (deref-pstats pd t1 tspans)))))\n\n(comment (enc/qb 1e6 @(new-pdata-local 10))) ; 245.08\n\n(def ^:dynamic *pdata* \"nnil iff dynamic profiling active\" nil)\n\n#?(:clj ; get nnil iff thread-local profiling active\n   (let [stack (java.util.Stack.) ; To support nesting\n         ^ThreadLocal proxy (proxy [ThreadLocal] [])]\n\n     (defn pdata-proxy-get [] (.get proxy))\n     (defn pdata-proxy-pop []\n       (if-let [stashed (when-not (.empty stack) (.pop stack))]\n         (do (.set proxy stashed) stashed)\n         (do (.set proxy nil)     nil)))\n\n     (defn pdata-proxy-push [v]\n       (if-let [to-stash (.get proxy)]\n         (do (.push stack to-stash) (.set proxy v) v)\n         (do                        (.set proxy v) v))))\n\n   :cljs\n   (let [stack #js [] ; To support nesting\n         state_ (volatile! false)] ; Automatically thread-local in js\n\n     (defn pdata-proxy-get [] @state_)\n     (defn pdata-proxy-pop []\n       (if-let [stashed (.pop stack)]\n         (vreset! state_ stashed)\n         (vreset! state_ nil)))\n\n     (defn pdata-proxy-push [v]\n       (if-let [to-stash @state_]\n         (do (.push stack to-stash) (vreset! state_ v))\n         (do                        (vreset! state_ v))))))\n\n(comment\n  (pdata-proxy-push \"foo\")\n  (pdata-proxy-pop)\n  (enc/qb 1e6 *pdata* (pdata-proxy-get)) ; [63.7 48.77]\n  (enc/qb 1e6  ; [507.58 74.62]\n    (binding [*pdata* \"foo\"])\n    (try (pdata-proxy-push \"foo\") (finally (pdata-proxy-pop)))))\n\n;;;; TimeSpan utils\n\n(deftype ElapsedTimeAcc [^long tsum ^long max-t1])\n(let [sort-tspans (fn [tspans] (sort-by (fn [^TimeSpan tspan] (.-t0 tspan)) tspans))]\n  (defn- tspans->tsum\n    \"Returns `tsum` (elapsed time) given collection of `TimeSpan`s.\n    Based on https://codereview.stackexchange.com/a/126927.\"\n    ^long [tspans]\n    (if (empty? tspans)\n      0\n      (let [sorted-tspans (sort-tspans tspans)] ; O(n.logn)\n        (.-tsum ^ElapsedTimeAcc\n          (reduce\n            (fn [^ElapsedTimeAcc acc ^TimeSpan tspan]\n              (let [t1     (.-t1     tspan)\n                    max-t1 (.-max-t1 acc)]\n                (if (> t1 max-t1)\n                  (let [t0   (.-t0   tspan)\n                        tsum (.-tsum acc)]\n                    (ElapsedTimeAcc. (+ tsum (- t1 (Math/max t0 max-t1))) t1))\n                  acc)))\n            (ElapsedTimeAcc. 0 0)\n            sorted-tspans))))))\n\n(comment\n  (tspans->tsum nil)\n  (tspans->tsum [])\n  (tspans->tsum [(TimeSpan. 1   3) (TimeSpan. 3 6)])\n  (tspans->tsum [(TimeSpan. 3   6) (TimeSpan. 1 3)])\n  (tspans->tsum [(TimeSpan. 1  10) (TimeSpan. 3 6)])\n  (enc/qb 1e6\n    (tspans->tsum\n      [(TimeSpan. 10 14)\n       (TimeSpan.  4 18)\n       (TimeSpan. 19 20)\n       (TimeSpan. 19 20)\n       (TimeSpan. 13 20)])))\n\n(defn- merge-tspans [^long nmax ^long t1 tspans0 tspans1]\n  (let [n0      (count tspans0)\n        n1      (count tspans1)\n        tspans2 (if (> n1 n0) (into tspans1 tspans0) (into tspans0 tspans1))]\n\n    (if (> (+ n0 n1) nmax) ; Compact, may lose some accuracy\n      (let [tsum (tspans->tsum tspans2)]\n        (list (TimeSpan. (- t1 tsum) t1)))\n      tspans2)))\n\n(comment\n  (merge-tspans 2 50\n    (list (TimeSpan. 1 10) (TimeSpan. 5  20))\n    (list (TimeSpan. 1 10) (TimeSpan. 20 50))))\n\n;;;;\n\n(defn- times-into-id-times\n  \"NB treats `from-times` as read-only (may be mutable `acc`)!\"\n  [to-id-times from-times]\n  (not-empty\n    (if-let [from-times (enc/force-ref from-times)]\n      (persistent!\n        (reduce\n          (fn [m ^Time in]\n            (let [id (.-id in)\n                  t  (.-t  in)]\n              (assoc! m id (conj (get m id) t))))\n          (transient (or to-id-times {}))\n          from-times))\n      to-id-times)))\n\n(comment\n  (times-into-id-times nil nil)\n  (times-into-id-times {}  nil)\n  (let [mt (mt-acc)]\n    (mt-add mt (Time. :foo 2))\n    (times-into-id-times {:foo '(1)} mt)))\n\n(defn- deref-pstats\n  \"PStats->{:clock _ :stats {<id> <stats/stats>}} (API output)\"\n  [^PData pd ^long t1 tspans]\n  (let [t0      (.-t0      pd)\n        pstate_ (.-pstate_ pd)\n        ^PState pstate (enc/force-ref pstate_)\n        id-times (.-id-times pstate)\n        id-stats (.-id-stats pstate)\n        id-times (times-into-id-times id-times (.-acc pstate))\n        id-stats ; Final {<id> <stats/stats>}\n        (reduce-kv\n          (fn [m id times]\n            (let [stats<times (stats/stats times)\n                  merged (reduce stats/merge-stats stats<times (get id-stats id))]\n              (assoc m id merged)))\n          id-times\n          id-times)]\n\n    {:stats id-stats\n     :clock {:t0 t0 :t1 t1 :total (tspans->tsum tspans)}}))\n\n(comment @@(new-pdata-local 10))\n\n(defn- fast-into [c0 c1] (if (> (count c0) (count c1)) (into c0 c1) (into c1 c0)))\n(comment (fast-into nil nil))\n\n(defn- merge-stats-when-needed [^long nmax stats]\n  (if (<= (count stats) nmax)\n    stats\n    (list (reduce stats/merge-stats stats))))\n\n(defn merge-pstats \"Compacting merge\"\n  ([     ps0 ps1] (merge-pstats nil ps0 ps1))\n  ([nmax ps0 ps1]\n   (if ps0\n     (if ps1\n       (let [^PStats ps0       ps0\n             ^PStats ps1       ps1\n             ^PData  pd0 (.-pd ps0)\n             ^PData  pd1 (.-pd ps1)\n\n             nmax (long (or nmax (.-nmax pd0)))\n             pd0-t0 (.-t0 pd0)\n             ps0-t1 (.-t1 ps0)\n             pd1-t0 (.-t0 pd1)\n             ps1-t1 (.-t1 ps1)\n\n             pd2-t0  (if (< pd0-t0 pd1-t0) pd0-t0 pd1-t0)\n             ps2-t1  (if (> ps0-t1 ps1-t1) ps0-t1 ps1-t1)\n             tspans2 (merge-tspans nmax ps2-t1 (.-tspans ps0) (.-tspans ps1))\n\n             ^PState pd0-pstate (enc/force-ref (.-pstate_ pd0))\n             ^PState pd1-pstate (enc/force-ref (.-pstate_ pd1))\n\n             pd0-id-times (times-into-id-times (.-id-times pd0-pstate) (.-acc pd0-pstate))\n             pd1-id-times (times-into-id-times (.-id-times pd1-pstate) (.-acc pd1-pstate))\n             pd0-id-stats (.-id-stats pd0-pstate)\n             pd1-id-stats (.-id-stats pd1-pstate)\n\n             ;; All ids in pd0 or pd1\n             pd2-ids (keys (conj (or pd0-id-times {}) pd1-id-times))\n\n             ;; Merge pd1 into pd0 to get pd2\n             [pd2-id-times pd2-id-stats]\n             (reduce\n               (fn [[pd2-id-times pd2-id-stats] id]\n                 (let [pd0-times (get pd0-id-times id)\n                       pd0-stats (get pd0-id-stats id)\n                       pd1-times (get pd1-id-times id)\n                       pd1-stats (get pd1-id-stats id)\n\n                       pd2-times (fast-into pd0-times pd1-times)\n                       pd2-stats (fast-into pd0-stats pd1-stats)]\n\n                   (if (<= (count pd2-times) nmax) ; Common case\n                     [(assoc pd2-id-times id pd2-times)\n                      (assoc pd2-id-stats id pd2-stats)]\n\n                     ;; Times need compaction\n                     (let [stats<times (stats/stats pd2-times)]\n                       [(assoc pd2-id-times id nil)\n                        (assoc pd2-id-stats id\n                          (merge-stats-when-needed nmax\n                            (conj pd2-stats stats<times)))]))))\n\n               [pd0-id-times pd0-id-stats]\n               pd2-ids)\n\n             pd2 (PData. nmax pd2-t0 (PState. nil pd2-id-times pd2-id-stats))]\n         (PStats. pd2 ps2-t1 tspans2 (delay (deref-pstats pd2 ps2-t1 tspans2))))\n\n       ps0)\n     ps1)))\n\n;;;; Time capture\n\n(defmacro ^:private atom? [x]\n  `(enc/if-cljs\n     (instance?    cljs.core.Atom ~x)\n     (instance? clojure.lang.Atom ~x)))\n\n(declare ^:private compact-pstate)\n(defn capture-time! [^PData pd id ns-elapsed]\n  (let [nmax    (.-nmax    pd)\n        pstate_ (.-pstate_ pd)\n        ^PState pstate @pstate_\n        acc (.-acc pstate)]\n\n    (if (atom? acc)\n\n      ;; Dynamic profiling\n      (let [?pulled-times\n            (loop []\n              (let [old-times @acc\n                    new-times (conj old-times (Time. id ns-elapsed))]\n                (if (<= (count new-times) nmax)\n                  (if (compare-and-set! acc old-times new-times) nil (recur))\n                  (if (compare-and-set! acc old-times nil) new-times (recur)))))]\n\n        (when-let [times ?pulled-times] ; Do compaction, rare\n          (let [t0 (enc/now-nano*)]\n            ;; Contention against `pstate_` unlikely since we just drained `acc`\n            (swap! pstate_ (fn [pstate] (compact-pstate pstate times nmax true)))\n            (recur pd :tufte/compaction (- (enc/now-nano*) t0)))))\n\n      (do ; Common case: thread-local profiling\n        (mt-add acc (Time. id ns-elapsed))\n\n        (when (> (mt-count acc) nmax) ; Do compaction, rare\n          (let [t0 (enc/now-nano*)]\n            (vreset! pstate_ (compact-pstate pstate acc nmax false))\n            (recur pd :tufte/compaction (- (enc/now-nano*) t0))))))))\n\n(defn- compact-pstate [^PState pstate pulled-times ^long nmax dynamic?]\n  ;; Note that compaction expense doesn't distort p times unless there's\n  ;; p nesting (where outer p time includes inner p's capture time).\n  (let [id-times (.-id-times pstate)\n        id-stats (.-id-stats pstate)\n        id-times (times-into-id-times id-times pulled-times)\n\n        [id-times id-stats]\n        (reduce-kv\n          (fn [acc id times]\n            (if (<= (count times) nmax)\n              acc\n              (let [[id-times id-stats] acc\n                    stats<times (stats/stats times)]\n                [(assoc id-times id nil)\n                 (assoc id-stats id\n                   (merge-stats-when-needed nmax\n                     (conj (get id-stats id) stats<times)))])))\n\n          [id-times id-stats]\n          id-times)\n\n        new-acc (if dynamic? (.-acc pstate) (mt-acc))]\n\n    (PState. new-acc id-times id-stats)))\n\n(comment\n  (try\n    (pdata-proxy-push (new-pdata-local 1e7))\n    (enc/qb 1e6 (capture-time! (pdata-proxy-get) :foo 1))\n    (finally (pdata-proxy-pop)))) ; 98.35\n\n;;;; Output handlers\n\n(enc/defonce handlers_ \"{<hid> <handler-fn>}\" (atom nil))\n\n#?(:clj\n   (enc/defonce ^:private ^ArrayBlockingQueue handler-queue\n     \"While user handlers should ideally be non-blocking, we'll use a queue\n     here to be safe + make sure we never tie up the execution thread.\"\n     (ArrayBlockingQueue. 1024)))\n\n(defn- handle-blocking! [m]\n  (enc/run-kv!\n    (fn [id f]\n      (enc/catching (f m) e\n        (enc/catching ; Esp. nb for Cljs\n          (println (str \"WARNING: Uncaught Tufte `\" id \"` handler error\\n\" e)))))\n    @handlers_))\n\n#?(:clj  (declare ^:private handler-thread_))\n#?(:cljs (defn handle! [m] (handle-blocking! m) nil))\n#?(:clj  (defn handle! [m] (.offer handler-queue m) @handler-thread_ nil))\n#?(:clj\n   (defonce ^:private handler-thread_\n     (delay\n       (let [f (fn []\n                 (loop []\n                   (let [m (.take handler-queue)]\n                     ;; Note: just drop if no registered handlers\n                     (handle-blocking! m)\n                     (recur))))]\n         (doto (Thread. f)\n           (.setDaemon true)\n           (.start))))))\n"]}